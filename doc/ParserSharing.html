<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ParserSharing</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_ParserSharing.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption" class="empty">&nbsp;</p></div><div id="content"><div id="module-header"><p class="caption">ParserSharing</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>ParserSharing is a general parsing library which merges parse trees such that the input is consumed in one traversal.
 From the user perspective the parsers are expressed as classical 
 recursive descendent parser using familiar parser combinators.
 The library is easily extensible, error control is also easily 
 implementable and the parsing is already done in an online fashion.
 Marcelo Sousa, Utrecht University 2011.                        
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Parser">Parser</a>  <span class="keyword">where</span><ul class="subs"><li><a href="#v:Sym">Sym</a> &#8759;  Char &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> Char  </li><li><a href="#v:Seq">Seq</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> (b &#8594; a) &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> b &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> a  </li><li><a href="#v:Alt">Alt</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> a  </li><li><a href="#v:Ret">Ret</a> &#8759;  a &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> a  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Pending">Pending</a>  <span class="keyword">where</span><ul class="subs"><li><a href="#v:Stack">Stack</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> p &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> r &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> (p, r)  </li><li><a href="#v:Split">Split</a> &#8759;  <a href="ParserSharing.html#t:Pending">Pending</a> r1 &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> r2 &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> (Either r1 r2)  </li><li><a href="#v:LazyShare">LazyShare</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> p &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> r &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> (<a href="ParserSharing.html#t:Share">Share</a> p r)  </li><li><a href="#v:Done">Done</a> &#8759;  <a href="ParserSharing.html#t:Pending">Pending</a> ()  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Share">Share</a> p r <span class="keyword">where</span><ul class="subs"><li><a href="#v:Share">Share</a> &#8759;  p &#8594; r &#8594; <a href="ParserSharing.html#t:Share">Share</a> p r  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:States">States</a> a = [<a href="ParserSharing.html#t:State">State</a> a]</li><li class="src short"><span class="keyword">data</span>  <a href="#t:State">State</a> a = &#8704; b . <a href="#v:State">State</a> (<a href="ParserSharing.html#t:Func">Func</a> b a) (<a href="ParserSharing.html#t:Pending">Pending</a> b)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Func">Func</a> b a <span class="keyword">where</span><ul class="subs"><li><a href="#v:Sem">Sem</a> &#8759;  [b &#8594; a] &#8594; <a href="ParserSharing.html#t:Func">Func</a> b a  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Equal">Equal</a>  <span class="keyword">where</span><ul class="subs"><li><a href="#v:Eq">Eq</a> &#8759;  <a href="ParserSharing.html#t:Equal">Equal</a> a a  </li></ul></li><li class="src short"><a href="#v:castParser">castParser</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; IO (StablePtr (<a href="ParserSharing.html#t:Parser">Parser</a> b))</li><li class="src short"><a href="#v:eq">eq</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> b &#8594; Maybe (<a href="ParserSharing.html#t:Equal">Equal</a> a b)</li><li class="src short"><a href="#v:runParser">runParser</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; [Char] &#8594; [a]</li><li class="src short"><a href="#v:parse">parse</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; [Char] &#8594; [a]</li><li class="src short"><a href="#v:evalStates">evalStates</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; [a]</li><li class="src short"><a href="#v:transition">transition</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; Char &#8594; <a href="ParserSharing.html#t:States">States</a> a</li><li class="src short"><a href="#v:reduce">reduce</a> &#8759;  Char &#8594; <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</li><li class="src short"><a href="#v:termination">termination</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; Bool</li><li class="src short"><a href="#v:isFolded">isFolded</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; Bool</li><li class="src short"><a href="#v:unFoldAndMerge">unFoldAndMerge</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</li><li class="src short"><a href="#v:unFoldNtAtHeads">unFoldNtAtHeads</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</li><li class="src short"><a href="#v:unFoldSplitAtHead">unFoldSplitAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</li><li class="src short"><a href="#v:unFoldShareAtHeads">unFoldShareAtHeads</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</li><li class="src short"><a href="#v:unFoldShareAtHead">unFoldShareAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</li><li class="src short"><a href="#v:unFoldSeqAtHead">unFoldSeqAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a &#8594; (<a href="ParserSharing.html#t:States">States</a> a, <a href="ParserSharing.html#t:States">States</a> a)</li><li class="src short"><a href="#v:unFoldRetAtHead">unFoldRetAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:State">State</a> a</li><li class="src short"><a href="#v:unFoldAltAtHead">unFoldAltAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</li><li class="src short"><a href="#v:unFoldAlt">unFoldAlt</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; [<a href="ParserSharing.html#t:Parser">Parser</a> a]</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Parser" class="def">Parser</a>  <span class="keyword">where</span></p><div class="doc"><p>A <code><a href="ParserSharing.html#t:Parser">Parser</a></code> is defunctionalized with a GADT where the constructors represent
  the normal parsers combinators. The default token type is <code>Char</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Sym" class="def">Sym</a> &#8759;  Char &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> Char</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Seq" class="def">Seq</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> (b &#8594; a) &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> b &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Alt" class="def">Alt</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Ret" class="def">Ret</a> &#8759;  a &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Parser" class="caption collapser" onclick="toggleSection('i:Parser')">Instances</p><div id="section.i:Parser" class="show"><table><tr><td class="src">Eq (<a href="ParserSharing.html#t:Parser">Parser</a> a)</td><td class="doc"><p>Eq instance for <code><a href="ParserSharing.html#t:Parser">Parser</a></code> that uses the Eq proof.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Pending" class="def">Pending</a>  <span class="keyword">where</span></p><div class="doc"><p>Continuations are represented by <code><a href="ParserSharing.html#t:Pending">Pending</a></code> which in the simple case is either <code><a href="ParserSharing.html#v:Done">Done</a></code> when there
  are no more parsers to process or a <code><a href="ParserSharing.html#v:Stack">Stack</a></code> of parsers. A <code><a href="ParserSharing.html#v:Split">Split</a></code> pending means that the current
  parse tree was being shared and should be splitted in two. <code><a href="ParserSharing.html#v:LazyShare">LazyShare</a></code> represents that part
  in the future of the tree that will be shared. This is useful because of the associativity of <code><a href="ParserSharing.html#v:Seq">Seq</a></code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Stack" class="def">Stack</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> p &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> r &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> (p, r)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Split" class="def">Split</a> &#8759;  <a href="ParserSharing.html#t:Pending">Pending</a> r1 &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> r2 &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> (Either r1 r2)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:LazyShare" class="def">LazyShare</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> p &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> r &#8594; <a href="ParserSharing.html#t:Pending">Pending</a> (<a href="ParserSharing.html#t:Share">Share</a> p r)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Done" class="def">Done</a> &#8759;  <a href="ParserSharing.html#t:Pending">Pending</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Share" class="def">Share</a> p r <span class="keyword">where</span></p><div class="doc"><p><code><a href="ParserSharing.html#t:Share">Share</a></code> represents a pair with a parser and a continuation 
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Share" class="def">Share</a> &#8759;  p &#8594; r &#8594; <a href="ParserSharing.html#t:Share">Share</a> p r</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:States" class="def">States</a> a = [<a href="ParserSharing.html#t:State">State</a> a]</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:State" class="def">State</a> a </p><div class="doc"><p><code><a href="ParserSharing.html#t:State">State</a></code> is an existential type that contains a list of semantic function that 
receive a cartesian product of the results of the parsers and applies them according
to their semantics. 
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src">&#8704; b . <a name="v:State" class="def">State</a> (<a href="ParserSharing.html#t:Func">Func</a> b a) (<a href="ParserSharing.html#t:Pending">Pending</a> b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Func" class="def">Func</a> b a <span class="keyword">where</span></p><div class="doc"><p>Generalizing <code><a href="ParserSharing.html#t:Func">Func</a></code> for N alternatives we would need a list of functions.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Sem" class="def">Sem</a> &#8759;  [b &#8594; a] &#8594; <a href="ParserSharing.html#t:Func">Func</a> b a</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Equal" class="def">Equal</a>  <span class="keyword">where</span></p><div class="doc"><p><code><a href="ParserSharing.html#t:Equal">Equal</a></code> data type for equality proof.
 The <code><a href="ParserSharing.html#v:Eq">Eq</a></code> construct expresses that two types are equal. 
 This is particulary useful for equality when using existential types.                                         
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Eq" class="def">Eq</a> &#8759;  <a href="ParserSharing.html#t:Equal">Equal</a> a a</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:castParser" class="def">castParser</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; IO (StablePtr (<a href="ParserSharing.html#t:Parser">Parser</a> b))</p><div class="doc"><p><code><a href="ParserSharing.html#v:castParser">castParser</a></code> casts a parser to another type that is inferred to be able to compare
     Stable Pointers. 
</p></div></div><div class="top"><p class="src"><a name="v:eq" class="def">eq</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharing.html#t:Parser">Parser</a> b &#8594; Maybe (<a href="ParserSharing.html#t:Equal">Equal</a> a b)</p><div class="doc"><p><code><a href="ParserSharing.html#v:eq">eq</a></code> is the equality function between two parsers. 
      Here <code>a</code> and <code>b</code> have the same type although the use of the existential types
      in <code><a href="ParserSharing.html#t:State">State</a></code> cannot allow us to assume so. That's the reason why the casting is 
      safe. For comparison we use Stable Pointers.
</p></div></div><div class="top"><p class="src"><a name="v:runParser" class="def">runParser</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; [Char] &#8594; [a]</p><div class="doc"><p><code><a href="ParserSharing.html#v:runParser">runParser</a></code> is the main function which the user has to invoke.  				  
</p></div></div><div class="top"><p class="src"><a name="v:parse" class="def">parse</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; [Char] &#8594; [a]</p><div class="doc"><p><code><a href="ParserSharing.html#v:parse">parse</a></code> is the iteratee that consumes input and updates the state by calling <code><a href="ParserSharing.html#v:transition">transition</a></code>.	
</p></div></div><div class="top"><p class="src"><a name="v:evalStates" class="def">evalStates</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; [a]</p><div class="doc"><p><code><a href="ParserSharing.html#v:evalStates">evalStates</a></code> triggers evaluation of the success functions. In that sense the process is not completely online.
 The functions is a bit more complicated than what it should be because of <code><a href="ParserSharing.html#v:Ret">Ret</a></code>.      
</p></div></div><div class="top"><p class="src"><a name="v:transition" class="def">transition</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; Char &#8594; <a href="ParserSharing.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharing.html#v:transition">transition</a></code> unfold and merges the states and then when their are ready to consume input it calls reduce.
</p></div></div><div class="top"><p class="src"><a name="v:reduce" class="def">reduce</a> &#8759;  Char &#8594; <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharing.html#v:reduce">reduce</a></code> consumes the token when the <code><a href="ParserSharing.html#t:States">States</a></code> are unfolded to a point where on top of the <code><a href="ParserSharing.html#v:Stack">Stack</a></code> we 
 have a <code><a href="ParserSharing.html#v:Sym">Sym</a></code> or the pending is <code><a href="ParserSharing.html#v:Done">Done</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:termination" class="def">termination</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; Bool</p><div class="doc"><p><code><a href="ParserSharing.html#v:termination">termination</a></code> check if all <code><a href="ParserSharing.html#t:Pending">Pending</a></code> in <code><a href="ParserSharing.html#t:States">States</a></code> are either <code><a href="ParserSharing.html#v:Done">Done</a></code> or have a <code><a href="ParserSharing.html#v:Sym">Sym</a></code> on top of the <code><a href="ParserSharing.html#v:Stack">Stack</a></code>.                          
</p></div></div><div class="top"><p class="src"><a name="v:isFolded" class="def">isFolded</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; Bool</p></div><div class="top"><p class="src"><a name="v:unFoldAndMerge" class="def">unFoldAndMerge</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharing.html#v:unFoldAndMerge">unFoldAndMerge</a></code> unfolds and merges states until they are ready to consuming input. 
 We start by unFolding the <code><a href="ParserSharing.html#v:Split">Split</a></code> pending, then the <code><a href="ParserSharing.html#v:LazyShare">LazyShare</a></code> and then the <code><a href="ParserSharing.html#t:State">State</a></code> with <code><a href="ParserSharing.html#v:Ret">Ret</a></code> on top of <code><a href="ParserSharing.html#v:Stack">Stack</a></code>. 
 This is because the sharing only happens with <code><a href="ParserSharing.html#v:Seq">Seq</a></code> and <code><a href="ParserSharing.html#v:Alt">Alt</a></code> which we process in the end. This is an highly inefficient 
 function at the moment.
</p></div></div><div class="top"><p class="src"><a name="v:unFoldNtAtHeads" class="def">unFoldNtAtHeads</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharing.html#v:unFoldNtAtHeads">unFoldNtAtHeads</a></code> is a simple dispatch function that uses pattern match to call specific-unFolding functions.
</p></div></div><div class="top"><p class="src"><a name="v:unFoldSplitAtHead" class="def">unFoldSplitAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharing.html#v:unFoldSplitAtHead">unFoldSplitAtHead</a></code> processes a <code><a href="ParserSharing.html#v:Split">Split</a></code> pending. Since when we are right-merging we simply take the head of the 
 <code><a href="ParserSharing.html#v:Sem">Sem</a></code> list and apply Left on the result. The other State is the tail of <code><a href="ParserSharing.html#v:Sem">Sem</a></code> with Right applied to its result. 
</p></div></div><div class="top"><p class="src"><a name="v:unFoldShareAtHeads" class="def">unFoldShareAtHeads</a> &#8759;  <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</p><div class="doc"><p>unFoldShareAtHeads dispatches all the states with <code><a href="ParserSharing.html#v:LazyShare">LazyShare</a></code> to <code><a href="ParserSharing.html#v:unFoldShareAtHead">unFoldShareAtHead</a></code>.                 
</p></div></div><div class="top"><p class="src"><a name="v:unFoldShareAtHead" class="def">unFoldShareAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharing.html#v:unFoldShareAtHead">unFoldShareAtHead</a></code> is going to merge the pairs of <code><a href="ParserSharing.html#v:LazyShare">LazyShare</a></code> that have the same initial parser. It might happen that one of the element
 of the pair was already discarded so in that case it's simply converted into a <code><a href="ParserSharing.html#v:Stack">Stack</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:unFoldSeqAtHead" class="def">unFoldSeqAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a &#8594; (<a href="ParserSharing.html#t:States">States</a> a, <a href="ParserSharing.html#t:States">States</a> a)</p><div class="doc"><p><code><a href="ParserSharing.html#v:unFoldSeqAtHead">unFoldSeqAtHead</a></code> unfolds the constructors <code><a href="ParserSharing.html#v:Seq">Seq</a></code> with <code><a href="ParserSharing.html#v:Seq">Seq</a></code>, <code><a href="ParserSharing.html#v:Seq">Seq</a></code> with <code><a href="ParserSharing.html#v:Ret">Ret</a></code> and <code><a href="ParserSharing.html#v:Seq">Seq</a></code> with a generic top of a stack since all the others
 should be already unfolded by now. It compares both sequenced parsers for equality and applies <code><a href="ParserSharing.html#v:Split">Split</a></code> and/or <code><a href="ParserSharing.html#v:LazyShare">LazyShare</a></code> depending if the their 
 are equal.	
</p></div></div><div class="top"><p class="src"><a name="v:unFoldRetAtHead" class="def">unFoldRetAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:State">State</a> a</p><div class="doc"><p><code><a href="ParserSharing.html#v:unFoldRetAtHead">unFoldRetAtHead</a></code> simply puts the value of <code><a href="ParserSharing.html#v:Ret">Ret</a></code> on top of the stack of values.
</p></div></div><div class="top"><p class="src"><a name="v:unFoldAltAtHead" class="def">unFoldAltAtHead</a> &#8759;  <a href="ParserSharing.html#t:State">State</a> a &#8594; <a href="ParserSharing.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharing.html#v:unFoldAltAtHead">unFoldAltAtHead</a></code> traverses the <code><a href="ParserSharing.html#v:Alt">Alt</a></code> parser to get a list of alternatives <code><a href="ParserSharing.html#v:unFoldAlt">unFoldAlt</a></code> and 
 uses <code>nub</code> to discard equal parsers to then build the list of corresponding States.
</p></div></div><div class="top"><p class="src"><a name="v:unFoldAlt" class="def">unFoldAlt</a> &#8759;  <a href="ParserSharing.html#t:Parser">Parser</a> a &#8594; [<a href="ParserSharing.html#t:Parser">Parser</a> a]</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.8.1</p></div></body></html>
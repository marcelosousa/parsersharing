<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ParserSharingSimple</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_ParserSharingSimple.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption" class="empty">&nbsp;</p></div><div id="content"><div id="module-header"><p class="caption">ParserSharingSimple</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>ParserSharingSimple is a simple parsing library which was extending to allow sharing.
 I have <code>published</code> this library so that the user can understand the basic principle of how
 the library works without sharing and then to move to the shared version.
 Marcelo Sousa, Utrecht University 2011.                        
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Parser">Parser</a>  <span class="keyword">where</span><ul class="subs"><li><a href="#v:Sym">Sym</a> &#8759;  Char &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> Char  </li><li><a href="#v:Ret">Ret</a> &#8759;  a &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> a  </li><li><a href="#v:Seq">Seq</a> &#8759;  <a href="ParserSharingSimple.html#t:Parser">Parser</a> (b &#8594; a) &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> b &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> a  </li><li><a href="#v:Alt">Alt</a> &#8759;  <a href="ParserSharingSimple.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> a  </li><li><a href="#v:Sat">Sat</a> &#8759;  (Char &#8594; Bool) &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> Char  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Pending">Pending</a>  <span class="keyword">where</span><ul class="subs"><li><a href="#v:Stack">Stack</a> &#8759;  <a href="ParserSharingSimple.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharingSimple.html#t:Pending">Pending</a> b &#8594; <a href="ParserSharingSimple.html#t:Pending">Pending</a> (a, b)  </li><li><a href="#v:Done">Done</a> &#8759;  <a href="ParserSharingSimple.html#t:Pending">Pending</a> ()  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:States">States</a> a = [<a href="ParserSharingSimple.html#t:State">State</a> a]</li><li class="src short"><span class="keyword">data</span>  <a href="#t:State">State</a> a = &#8704; b . <a href="#v:State">State</a> (b &#8594; a) (<a href="ParserSharingSimple.html#t:Pending">Pending</a> b)</li><li class="src short"><a href="#v:runParser">runParser</a> &#8759;  <a href="ParserSharingSimple.html#t:Parser">Parser</a> a &#8594; [Char] &#8594; [a]</li><li class="src short"><a href="#v:parse">parse</a> &#8759;  <a href="ParserSharingSimple.html#t:States">States</a> a &#8594; [Char] &#8594; [a]</li><li class="src short"><a href="#v:evalStates">evalStates</a> &#8759;  <a href="ParserSharingSimple.html#t:States">States</a> a &#8594; [a]</li><li class="src short"><a href="#v:transition">transition</a> &#8759;  <a href="ParserSharingSimple.html#t:States">States</a> a &#8594; Char &#8594; <a href="ParserSharingSimple.html#t:States">States</a> a</li><li class="src short"><a href="#v:reduce">reduce</a> &#8759;  Char &#8594; <a href="ParserSharingSimple.html#t:States">States</a> a &#8594; <a href="ParserSharingSimple.html#t:State">State</a> a &#8594; <a href="ParserSharingSimple.html#t:States">States</a> a</li><li class="src short"><a href="#v:unFoldNtAtHeads">unFoldNtAtHeads</a> &#8759;  <a href="ParserSharingSimple.html#t:State">State</a> a &#8594; <a href="ParserSharingSimple.html#t:States">States</a> a</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Parser" class="def">Parser</a>  <span class="keyword">where</span></p><div class="doc"><p>A <code><a href="ParserSharingSimple.html#t:Parser">Parser</a></code> is defunctionalized with a GADT where the constructors represent
  the normal parsers combinators. The default token type is <code>Char</code>.
  I've also added here the constructor <code><a href="ParserSharingSimple.html#v:Sat">Sat</a></code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Sym" class="def">Sym</a> &#8759;  Char &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> Char</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Ret" class="def">Ret</a> &#8759;  a &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Seq" class="def">Seq</a> &#8759;  <a href="ParserSharingSimple.html#t:Parser">Parser</a> (b &#8594; a) &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> b &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Alt" class="def">Alt</a> &#8759;  <a href="ParserSharingSimple.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Sat" class="def">Sat</a> &#8759;  (Char &#8594; Bool) &#8594; <a href="ParserSharingSimple.html#t:Parser">Parser</a> Char</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Pending" class="def">Pending</a>  <span class="keyword">where</span></p><div class="doc"><p>Continuations are represented by <code><a href="ParserSharingSimple.html#t:Pending">Pending</a></code> which in the simple case is either <code><a href="ParserSharingSimple.html#v:Done">Done</a></code> when there
  are no more parsers to process or a <code><a href="ParserSharingSimple.html#v:Stack">Stack</a></code> of parsers.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Stack" class="def">Stack</a> &#8759;  <a href="ParserSharingSimple.html#t:Parser">Parser</a> a &#8594; <a href="ParserSharingSimple.html#t:Pending">Pending</a> b &#8594; <a href="ParserSharingSimple.html#t:Pending">Pending</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Done" class="def">Done</a> &#8759;  <a href="ParserSharingSimple.html#t:Pending">Pending</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:States" class="def">States</a> a = [<a href="ParserSharingSimple.html#t:State">State</a> a]</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:State" class="def">State</a> a </p><div class="doc"><p><code><a href="ParserSharingSimple.html#t:State">State</a></code> is an existential type that contains a semantic function that 
receive a cartesian product of the results of the parsers and applies them according
to their semantics. 
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src">&#8704; b . <a name="v:State" class="def">State</a> (b &#8594; a) (<a href="ParserSharingSimple.html#t:Pending">Pending</a> b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:runParser" class="def">runParser</a> &#8759;  <a href="ParserSharingSimple.html#t:Parser">Parser</a> a &#8594; [Char] &#8594; [a]</p><div class="doc"><p><code><a href="ParserSharingSimple.html#v:runParser">runParser</a></code> is the main function which the user has to invoke.
</p></div></div><div class="top"><p class="src"><a name="v:parse" class="def">parse</a> &#8759;  <a href="ParserSharingSimple.html#t:States">States</a> a &#8594; [Char] &#8594; [a]</p><div class="doc"><p><code><a href="ParserSharingSimple.html#v:parse">parse</a></code> is the iteratee that consumes input and updates the state by calling <code><a href="ParserSharingSimple.html#v:transition">transition</a></code>.	
</p></div></div><div class="top"><p class="src"><a name="v:evalStates" class="def">evalStates</a> &#8759;  <a href="ParserSharingSimple.html#t:States">States</a> a &#8594; [a]</p><div class="doc"><p><code><a href="ParserSharingSimple.html#v:evalStates">evalStates</a></code> triggers evaluation of the success functions. In that sense the process is not completely online.
 The functions is a bit more complicated than what it should be because of <code><a href="ParserSharingSimple.html#v:Ret">Ret</a></code>.
 Notice that in case of failure the state is discarded.       
</p></div></div><div class="top"><p class="src"><a name="v:transition" class="def">transition</a> &#8759;  <a href="ParserSharingSimple.html#t:States">States</a> a &#8594; Char &#8594; <a href="ParserSharingSimple.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharingSimple.html#v:transition">transition</a></code> unfold the top of the stack until we have a <code><a href="ParserSharingSimple.html#v:Sym">Sym</a></code> or 'Done and then calls <code><a href="ParserSharingSimple.html#v:reduce">reduce</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:reduce" class="def">reduce</a> &#8759;  Char &#8594; <a href="ParserSharingSimple.html#t:States">States</a> a &#8594; <a href="ParserSharingSimple.html#t:State">State</a> a &#8594; <a href="ParserSharingSimple.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharingSimple.html#v:reduce">reduce</a></code> consumes the token when the <code><a href="ParserSharingSimple.html#t:States">States</a></code> are unfolded to a point where on top of the <code><a href="ParserSharingSimple.html#v:Stack">Stack</a></code> we 
 have a <code><a href="ParserSharingSimple.html#v:Sym">Sym</a></code> or the pending is <code><a href="ParserSharingSimple.html#v:Done">Done</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:unFoldNtAtHeads" class="def">unFoldNtAtHeads</a> &#8759;  <a href="ParserSharingSimple.html#t:State">State</a> a &#8594; <a href="ParserSharingSimple.html#t:States">States</a> a</p><div class="doc"><p><code><a href="ParserSharingSimple.html#v:unFoldNtAtHeads">unFoldNtAtHeads</a></code> pattern-matches on the top of the <code><a href="ParserSharingSimple.html#t:Pending">Pending</a></code> and it's either a <code><a href="ParserSharingSimple.html#v:reduce">reduce</a></code> state does not change it. 
 If there is a <code><a href="ParserSharingSimple.html#v:Ret">Ret</a></code> on the top of the <code><a href="ParserSharingSimple.html#v:Stack">Stack</a></code> it will put the value on top of stack represented by the cartesian product 
 and use that as argument to the semantic function.
 If there is a <code><a href="ParserSharingSimple.html#v:Seq">Seq</a></code> on top of the <code><a href="ParserSharingSimple.html#v:Stack">Stack</a></code> it will unfold it into a new <code><a href="ParserSharingSimple.html#v:Stack">Stack</a></code> and it will apply the result function of the first parser 
 to the result value of the second one and wrap that value into a pair that is the argument of the overall semantic function.
 If there is a <code><a href="ParserSharingSimple.html#v:Alt">Alt</a></code> on top of the <code><a href="ParserSharingSimple.html#v:Stack">Stack</a></code> it will simply create two states out of it.
 Note that <code><a href="ParserSharingSimple.html#v:unFoldNtAtHeads">unFoldNtAtHeads</a></code> is being recursively called until we can't unFold anymore.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.8.1</p></div></body></html>